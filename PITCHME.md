### Pythonでクラスを書こう

- 2020年2月20日 初版
- 2020年2月21日 第二版

---

### 対象
- Pythonの関数が書ける人 |
- Pythonのクラスを勉強したい人 |

---

### クラスとは

---

### 公式ドキュメント

#### 9. クラス — Python 3.8.2rc1 ドキュメント

https://docs.python.org/ja/3/tutorial/classes.html

- クラスはデータと機能を組み合わせる方法を提供します。 
新規にクラスを作成することで、新しいオブジェクトの 型 を作成し、その型を持つ新しい インスタンス が作れます。 
クラスのそれぞれのインスタンスは自身の状態を保持する属性を持てます。 
クラスのインスタンスは、その状態を変更するための (そのクラスが定義する) メソッドも持てます。

---

### まずはクラスをどのように使うのか見てみましょう。

---

### 注意
これからお見せするソースは説明しやすいように、
積極的に日本語化していますが
実際に開発する時は日本語で書かないで下さい。

---

```
class 車の設計図:

    def __init__(self, 色='白'):
        self.色 = 色

    def 色教えて(self):
        メッセージ = '車の色は{}です'
        print(メッセージ.format(self.色))

    def 色変えて(self, 色):
        self.色 = 色
        メッセージ = '車の色を{}に変更しました'
        print(メッセージ.format(self.色))

私の車 = 車の設計図()
私の車.色教えて()
私の車.色変えて('黒')
```

@[1-13](こちらがクラスそのものにあたります)
@[3,6,10](クラスには「def」から始まる関数のようながあります)
@[3,6,10](これはメソッドと呼ばれ第一引数には必ず「self」を記述します)
@[3,10](メソッドに引数が必要な場合、第二引数以降に記述します)
@[4](頭に「self.」がついた変数はインスタンス変数と呼ばれ)
@[4,8,9,11,13](クラス内で共通利用する変数になります)
@[7,12](「self.」がつかない変数の場合)
@[7](スコープはそのメソッド内のみとなります)
@[15-17](こちらがクラスを呼び出す側です)
@[1-17](ではトレースしながら挙動を確認してみます)
@[15](まず「車の設計図」を元に「私の車」を作成します)
@[1-13,15](「車の設計図」はクラスと呼ばれ)
@[15](「車の設計図」から生成した「私の車」の実体のことを)
@[15](インスタンスと呼ばれます)
@[1-4,15](クラス側ではインスタンス化されるとき)
@[3](特殊メソッドである「\_\_init\_\_」が定義されていると)
@[3](「\_\_init\_\_」メソッドが実行されます)
@[3](「\_\_init\_\_」メソッドが必要ない場合は記述しなくてもOKです)
@[3](今回は色を指定できるようにするために利用しています)
@[15](もし「私の車 = 車の設計図('青')」としてインスタンスを生成した場合)
@[3-4,15](「self.色 」には、「青」がセットされます)
@[15](「私の車 = 車の設計図()」としてインスタンスを生成した場合)
@[15](引数が指定されていないので)
@[3,15](色のデフォルト値である「白」が)
@[4,15](「self.色」にセットされます)
@[16](「私の車.色教えて()」を使うと)
@[16,6-8](クラス側では「メッセージ」と「self.色」が結合され)
@[16,6-8](「車の色は白です」と出力します)
@[17](「私の車.色変えて('黒')」を使うと)
@[17,10-13](クラス側では)
@[17,11](「self.色」に「黒」がセットされ)
@[17,12-13](「メッセージ」と「self.色」が結合され)
@[17,12-13](「車の色を黒に変更しました」と出力します)
@[1−１５](クラスのイメージがつきましたでしょうか)

---

もし、これを関数ですべてやると
こんな感じになります

---

関数版

```
def 色教えて(車データ):
    メッセージ = '車の色は{}です'
    print(メッセージ.format(車データ['色']))

def 色変えて(車データ, 色):
    車データ['色'] = 色
    メッセージ = '車の色を{}に変更しました'
    print(メッセージ.format(車データ['色']))
    return 車データ

私の車 = {'色': '白'}
色教えて(私の車)
私の車 = 色変えて(私の車, '黒')
```
@[1-13](クラス版と比較します)

---

クラス版

```
class 車の設計図:

    def __init__(self, 色='白'):
        self.色 = 色

    def 色教えて(self):
        メッセージ = '車の色は{}です'
        print(メッセージ.format(self.色))

    def 色変えて(self, 色):
        self.色 = 色
        メッセージ = '車の色を{}に変更しました'
        print(メッセージ.format(self.色))

私の車 = 車の設計図()
私の車.色教えて()
私の車.色変えて('黒')
```

@[1-17](関数版に戻します)

---

```
def 色教えて(車データ):
    メッセージ = '車の色は{}です'
    print(メッセージ.format(車データ['色']))

def 色変えて(車データ, 色):
    車データ['色'] = 色
    メッセージ = '車の色を{}に変更しました'
    print(メッセージ.format(車データ['色']))
    return 車データ

私の車 = {'色': '白'}
色教えて(私の車)
私の車 = 色変えて(私の車, '黒')
```

@[1-9](特殊メソッドの「\_\_init\_\_」がないので)
@[1-9](関数にするとコードが短く見えます)
@[11](関数ではデータを保持できないので呼び出し側で管理しています)
@[1,5](また、クラスでは「self」であった引数が)
@[1,5](関数では「車データ」になっています)
@[11-13](これは関数の場合、データの管理を自分自身で行う必要があるので)
@[1,5,12,13](毎回、関数に渡してあげる必要があります)
@[5,6,13](データに変更を加えた場合は)
@[5,9,13](かならず戻り値を取得する必要があります)
@[1-13]()

---

もし、「あなたの車」や「君の車」が増えたとき

---

関数版

```
私の車 = {'色': '白'}
色教えて(私の車)
私の車 = 色変えて(私の車, '黒')

あなたの車 = {'色': '赤'}
色教えて(あなたの車)
あなたの車 = 色変えて(あなたの車, '銀')

君の車 = {'色': '緑'}
色教えて(君の車)
君の車 = 色変えて(君の車 , '金')
```

@[1-11](データを定義したり、渡したり、入れ直したりと大変です)

---

クラス版

```
私の車 = 車の設計図()
私の車.色教えて()
私の車.色変えて('黒')

あなたの車 = 車の設計図('赤')
あなたの車.色教えて()
あなたの車.色変えて('銀')

君の車 = 車の設計図('緑')
君の車.色教えて()
君の車.色変えて('金')
```
@[1-11](クラス化した場合はデータの管理が楽になります)
@[1-11](データをセットするだけです)
@[1-11](見比べてどうでしょうか)

---

### 関数とクラスの違い

| 関数 | クラス |
| --- | --- |
|単体で利用可能|インスタンス化して利用|
|データの保持ができない | インスタンスの内部にデータが保持できる |
|                   |継承可能などなど...               |

---

### よくある質問

---

#### Q.関数とクラスとクラスどちらがいいの
#### A.クラスも関数型も一長一短ありがあり、どちらが良くてどちらが悪いというものではない。その時、その時で最適な方を使えばいいと思います。

---

#### Q.クラスメソッドの第一引数になぜ「self」の記述が必要なの

#### A. Pythonの生みの親Guidoがブログエントリでそのことを説明しています
http://neopythonic.blogspot.com/2008/10/why-explicit-self-has-to-stay.html

---

例題の「車の設計図」クラスを使って独自解釈で試してみます。

---

「self」を明示的にメソッドの引数として記述することによって，
「`私の車 = 車の設計図()`」 の時、  
「`私の車.色変えて('赤')`」 と   
「`車の設計図.色変えて(私の車, '赤')`」は  
`論的同等性`が示すことができる。  
とあります。

---

試してみます

---

```python
class 車の設計図:
    def __init__(self, 色='白'):
        self.色 = 色
    def 色教えて(self):
        メッセージ = '車の色は{}です'
        print(メッセージ.format(self.色))
    def 色変えて(self, 色):
        self.色 = 色
        メッセージ = '車の色を{}に変更しました'
        print(メッセージ.format(self.色))
        
私の車 = 車の設計図()
if 私の車.色変えて('赤') == 車の設計図.色変えて(私の車, '赤'):
    print('理論的同等性') # 理論的同等性
```

@[13-14](結果は「理論的同等性」と出力されます)
@[0]()

---

- メソッドに「self」が必要な理由のもう一つの理由として
クラスを動的に追加できる機能です。
たとえば、空っぽのクラスのメソッドに対応する関数を追加することにより
「車の設計図」クラスと完全に同等のクラスを作成できます。

---

試してみます

---
```python
# 空のクラスを定義
class 車の設計図:
    pass
# グローバル関数を定義
def 色教えて関数(車データ):
    メッセージ = '車の色は{}です'
    print(メッセージ.format(車データ.色))
def 色変えて関数(車データ, 色):
    車データ.色 = 色
    メッセージ = '車の色を{}に変更しました'
    print(メッセージ.format(車データ.色))
# クラスメソッドとしてグローバル関数を挿入
車の設計図.色教えて = 色教えて関数
車の設計図.色変えて = 色変えて関数
# 実際に動作するか確認
私の車 = 車の設計図()
私の車.色変えて('赤')  # 車の色を赤に変更しました
私の車.色教えて()      # 車の色は赤です
```
@[17](結果は「車の色を赤に変更しました」と出力されます)
@[18](結果は「車の色は赤です」と出力されます)
@[0]()

---

かなり難解な理由ですが、正しく動作しました。
以上が生みの親によるメソッドの第一引数に「self」が必要な理由となります。

---

#### Q.なぜクラスで「self」という文字列を使うの
#### A.「self」の使用がPEPで推奨されているからです。

「クラスメソッドの第一引数になぜ「self」の記述が必要なの」でも示したように、「self」を「車データ」という文字列であっても正しく動作します。
が、メンテナンス性が悪くなるので「self」を使いましょう。

---

### 質問受付

---

### もうすこし複雑なクラスを作ってみる？

---

### お題

ファーストフードのレジシステム

---

### レジシステムに必要な機能

- メニューを登録 |
- 注文を登録 |
- 注文を確認 |
- 注文の合計金額を確認 |
- お金を受領しよう |
- お釣りを確認しよう |
- 領収書を発行 |

---

システム名はクラス名に機能はメソッド名に利用します。

---

|利用用途|システム名/機能名       |クラス名/メソッド名|
|---    |--                   |-- |--- |
|クラス名 | ファーストフードレジシステム |  | 
|メソッド名| メニューを登録          |  |
|メソッド名| 注文を登録            |  |
|メソッド名| 注文を確認            |  |
|メソッド名| 注文の合計金額を確認    |  |
|メソッド名| お金を受領しよう        |  |
|メソッド名| お釣りを確認しよう       |  |
|メソッド名| 領収書を発行          |  |

---
### クラス名/メソッド名を命名してみよう

Pythonの命名規則はPEPに従うと後々楽です

https://pep8-ja.readthedocs.io/ja/latest/

---

|利用用途|システム名/機能名       |クラス名/メソッド名|
|---    |--                   |-- |--- |
|クラス名 | ファーストフードレジシステム | FastFoodSystem | 
|メソッド名| メニューを登録          | set_menu |
|メソッド名| 注文を登録            | set_order |
|メソッド名| 注文を確認            | get_order |
|メソッド名| 注文の合計金額を確認    | get_total_price |
|メソッド名| お金を受領しよう        | set_deposit |
|メソッド名| お釣りを確認しよう       | get_change |
|メソッド名| 領収書を発行          | get_receipt |

---

### クラスを作成

---

```python
class FastFoodSystem:
    """ ファーストフードレジシステム """
    def set_menu(self, menu):
        """ メニューを登録 """
        pass
    def set_order(self, order):
        """ 注文を登録 """
        pass
    def get_order(self):
        """ 注文を確認 """
        pass
    def get_total_price(self):
        """ 注文の合計金額を確認 """
        pass
    def set_deposit(self, deposit):
        """ お金を受領しよう """
        pass
    def get_change(self):
        """ お釣りを確認しよう """
        pass
    def get_receipt(self):
        """ 領収書を発行 """
        pass
```
@[2,4,7,10,13,16,19](機能名はコメントに利用)
@[1,3,6,9,12,15,18](クラス名とメソッドを設置)
@[1,3,6,9,12,15,18](お決まりの「self」を第一引数にセット)
@[3,6,15](メソッドとして引数が必要なものは第二引数以降にセット)
@[5](ちなみに pass はコードとしては何も実行したくない場合のプレースホルダです)
@[1-20](これだけでなにもしないクラスが完成)
@[1-20](ここで「test = FastFoodSystem（）」としてインスタンス化し)
@[1-20](「test.get_order()」としてもエラーにらないです。)
@[11](理由は pass しているからです)
@[1-20](pass 部分を書き換えることで目的にあったクラスが完成します)

---

このプログラムが実行できるように書き換えよう

```python
macdonald = FastFoodSystem()
macdonald.set_menu({'コーラー': 100, 'ハンバーガー': 110, 'ポテト': 100})
macdonald.set_order('ハンバーガー')
macdonald.set_order('ポテト')
macdonald.set_order('コーラー')
macdonald.set_order('モスバーガー')
macdonald.get_order()           # ['ハンバーガー', 'ポテト', 'コーラー']
macdonald.get_total_price()     # 310
macdonald.set_deposit(500)
macdonald.get_change()          # 190
macdonald.get_receipt()         # {'change': 190,
                                #  'deposit': 500,
                                #  'order_list': ['ハンバーガー', 'ポテト', 'コーラー'],
                                #  'total_price': 310}
```

---

### では実際にメソッド内に手を加えてみます٩(ˊᗜˋ*)و 

ここにソースがあるよ！
https://raw.githubusercontent.com/mykysyk/slide-python-class/master/vanilla.py 

---

```python
class FastFoodSystem:
    """ ファーストフードレジシステム """
    
    def __init__(self):
        self.order_list = []
        
    def set_menu(self, menu):
        """ メニューを登録 """
        self.menu_dict = menu
        
    def set_order(self, order):
        """ 注文を登録 """
        if order in self.menu_dict:
            self.order_list.append(order)
            
    def get_order(self):
        """ 注文を確認 """
        print(self.order_list)
```

@[7](まずは「set_menu」メソッドを書き換えます)
@[7](「set_menu」メソッドは引数「menu」があります)
@[7]({'コーラー': 100, 'ハンバーガー': 110, 'ポテト': 100}の)
@[7](辞書型の「menu」データがくることを想定しています)
@[7,9](「self.menu_dict」に値を登録できるようにします)
@[7-9](これで「set_menu」メソッドの完成です)
@[12](次に「set_order」メソッドを書き換えます)
@[13](注文商品がメニューにあるときだけ)
@[13-14](「注文リスト」に追加できるようにします)
@[14](しかし「注文リスト」である「self.order_list」は)
@[14](リストとして宣言されておらず「append」するとエラーとなるので)
@[4](特殊メソッドを作成し)
@[4,5](「注文リスト」を配列で初期化させます)
@[12-14](「set_menu」メソッドの完成です)
@[16](次は「get_order」メソッドを書き換えます)
@[14](ここで追加した「注文リスト」の内容を)
@[18](出力する処理を入れます)
@[16-18](これで「get_order」メソッドの完成です)
@[0](ここまでで正しく動作するか確認してみましょう。)

---

```python
macdonald = FastFoodSystem()
macdonald.set_menu({'コーラー': 100, 'ハンバーガー': 110, 'ポテト': 100})
macdonald.set_order('ハンバーガー')
macdonald.set_order('ポテト')
macdonald.set_order('コーラー')
macdonald.set_order('モスバーガー')
macdonald.get_order() # ['ハンバーガー', 'ポテト', 'コーラー']
```

---

どうですか、想定通りのデータが出力されましたか

---

残りのメソッドは各自でためしてみましょう。

サンプルではマクドナルドでしたが、モスであったり吉野家とかに変更してもいいです。
メニューにない商品を登録したときにエラーを出すパターンとか
もって帰るか、そこで食べるのかで消費税の軽減税率計算を実施するパターンとか
の機能を追加してもOKです。

---

### 実例

https://github.com/mykysyk/slide-python-class/blob/master/fastfoodsystem.py

---

### おわり
